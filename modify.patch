diff --git a/MTE-kernel/arch/arm64/kernel/hakc/hakc.c b/MTE-kernel/arch/arm64/kernel/hakc/hakc.c
index f5cdf3489..38159511b 100644
--- a/MTE-kernel/arch/arm64/kernel/hakc/hakc.c
+++ b/MTE-kernel/arch/arm64/kernel/hakc/hakc.c
@@ -14,7 +14,7 @@
 
 #define HAKC_INFO(fmt, ...)                                                    \
 	if (HAKC_DEBUG) {                                                      \
-		pr_info(fmt, ##__VA_ARGS__);                                   \
+		pr_err(fmt, ##__VA_ARGS__);                                   \
 	}
 #define HAKC_ERR(fmt, ...)                                                     \
 	if (HAKC_DEBUG) {                                                      \
@@ -37,7 +37,7 @@ struct percpu_info {
 	void *percpu_addr;
 };
 
-volatile bool mte_global_debug = false;
+volatile bool mte_global_debug = true;
 
 EXPORT_SYMBOL(mte_global_debug);
 
@@ -409,16 +409,24 @@ static void *check_hakc_access(const void *address,
 	HAKC_INFO("access_tok = 0x%lx\taddress = 0x%lx\n", access_tok, address);
 	addr_claque = get_hakc_address_claque(address);
 
+	// TODO: The `kmalloc` function is defined as `always_inline` in the kernel.
+	// This prevents PMC-Pass instrumentation from correctly intercepting the
+	// call to `check_hakc_data_access`.
+	// if(!VALID_CLAQUE(addr_claque)) {
+	// 	HAKC_INFO("Invalid claque ID: 0x%lx\n", address);
+	// 	return (void *)address;
+	// }
+
 	addr_color = _get_mte_tag(safe_addr);
 	HAKC_INFO("0x%lx is colored %s and in claque %lu\n", address,
 		  get_hakc_color_name(addr_color), addr_claque);
 
-	ctx_addr = (const void *)((u64)address | CLAQUE_BIT_MASK_2);
+	ctx_addr = (const void *)HAKC_CONTEXT_ADDR(address);
 	salt = obtain_modifier_cert(addr_color, addr_claque) & access_tok;
 	HAKC_INFO("ctx_addr = %lx salt = %lx\n", ctx_addr, salt);
-	result = (unsigned long)auth_func(
-		(const void *)HAKC_CONTEXT_ADDR(ctx_addr), salt);
-	result |= (0x0000FFFFFFFFFFFF & (unsigned long)ctx_addr);
+	result = (unsigned long)auth_func(ctx_addr, salt);
+	// result |= (0x0000FFFFFFFFFFFF & (unsigned long)ctx_addr);
+	result |= HAKC_CLAQUE_ADDR(address);
 
 	HAKC_INFO("result = %lx address = %lx\n", result, address);
 	if (HAKC_ALLOW) {
@@ -528,6 +536,7 @@ void *hakc_sign_pointer(void *addr, claque_id_t claque_id, clique_color_t color,
 	* */
 	if (VALID_CLAQUE(claque_id) /*&& color != START_CLIQUE*/) {
 		addr = HAKC_GET_SAFE_PTR(addr);
+		addr = (void *)EMBED_CLAQUE_ID(claque_id, addr);
 		if (is_code) {
 			addr = (void *)compute_code_pac((void *)addr, color,
 							claque_id);
@@ -538,7 +547,6 @@ void *hakc_sign_pointer(void *addr, claque_id_t claque_id, clique_color_t color,
 #if IS_ENABLED(CONFIG_PAC_MTE_EVAL_CODEGEN)
 		addr = HAKC_GET_SAFE_PTR(addr);
 #else
-		addr = (void *)EMBED_CLAQUE_ID(claque_id, addr);
 #endif
 		HAKC_INFO("TRANSFER RESULT to %d %lx %d %lx\n", claque_id, addr,
 			  get_hakc_address_claque((void *)addr),
diff --git a/MTE-kernel/drivers/net/dummy.c b/MTE-kernel/drivers/net/dummy.c
index bab3a9bb5..5f5cfe56c 100644
--- a/MTE-kernel/drivers/net/dummy.c
+++ b/MTE-kernel/drivers/net/dummy.c
@@ -41,10 +41,79 @@
 #include <net/rtnetlink.h>
 #include <linux/u64_stats_sync.h>
 
+#include <linux/hakc.h>
+
+#if IS_ENABLED(CONFIG_PAC_MTE_COMPART)
+#include <linux/hakc-transfer.h>
+HAKC_MODULE_CLAQUE(7, BLUE_CLIQUE,
+		   HAKC_MASK_COLOR(SILVER_CLIQUE) |
+			   HAKC_MASK_COLOR(GREEN_CLIQUE) |
+			   HAKC_MASK_COLOR(PURPLE_CLIQUE));
+HAKC_EXIT(HAKC_ENTRY_TOKEN(0, HAKC_MASK_COLOR(SILVER_CLIQUE)),
+	  HAKC_ENTRY_TOKEN(1, HAKC_MASK_COLOR(SILVER_CLIQUE)));
+#endif
+
 #define DRV_NAME	"dummy"
 
+/* Use one of the SIOCDEVPRIVATE slots (0â€“15) for driver-private ioctls */
+#define DUMMY_IOCTL_TEST_MIXED (SIOCDEVPRIVATE + 12)
+
 static int numdummies = 1;
 
+DEFINE_MUTEX(global_mutex);
+DEFINE_SPINLOCK(global_spin_lock);
+
+struct a_struct {
+	int first, second;
+};
+
+struct a_struct var_a = { 1, 1 };
+int global_var1 = 1;
+
+noinline unsigned long doSomethingDemo(void) // normal syscall
+{
+	int i;
+	int *lll;
+	lll = kmalloc(sizeof(int), GFP_KERNEL); 
+	if (!lll) {
+		pr_err("Memory allocation failed for lll\n");
+		return -ENOMEM;
+	}
+	lll = hakc_transfer_to_clique(lll, sizeof(int), __claque_id, __color,
+				      false);
+
+	mutex_lock(&global_mutex);
+	for (i = 0; i < 3; i++) {
+		global_var1 = global_var1 + 1;
+		var_a.first = var_a.first + 1;
+	}
+	mutex_unlock(&global_mutex);
+	kfree(lll);
+
+	return 0;
+}
+
+static noinline int dummy_ioctl(struct net_device *dev, struct ifreq *ifr,
+				int cmd)
+{
+	// struct dummy_priv *p = netdev_priv(dev);
+	int err = 0;
+#if IS_ENABLED(CONFIG_PAC_MTE_COMPART)
+	// dev = hakc_transfer_to_clique(dev, sizeof(*dev), __claque_id, __color, false);
+	// p = hakc_transfer_to_clique(p, sizeof(*p), __claque_id, __color, false);
+#endif
+
+	switch (cmd) {
+	case DUMMY_IOCTL_TEST_MIXED:
+		err = doSomethingDemo();
+		break;
+	default:
+		err = 123;
+	}
+
+	return err;
+}
+
 /* fake multicast ability */
 static void set_multicast_list(struct net_device *dev)
 {
@@ -56,6 +125,93 @@ static void dummy_get_stats64(struct net_device *dev,
 	dev_lstats_read(dev, &stats->tx_packets, &stats->tx_bytes);
 }
 
+#if IS_ENABLED(CONFIG_PAC_MTE_COMPART)
+HAKC_SYMBOL_CLAQUE(dummy_xmit, 7, GREEN_CLIQUE,
+		   HAKC_MASK_COLOR(SILVER_CLIQUE) |
+			   HAKC_MASK_COLOR(BLUE_CLIQUE));
+
+noinline netdev_tx_t dummy_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	pr_crit("dummy_xmit: 1\n");
+
+	dev = hakc_transfer_to_clique(dev, sizeof(*dev), __claque_id_dummy_xmit,
+				      __color_dummy_xmit, false);
+	skb = hakc_transfer_to_clique(skb, sizeof(*skb), __claque_id_dummy_xmit,
+				      __color_dummy_xmit, false);
+
+	pr_crit("dummy_xmit: 2\n");
+
+	// dev->lstats = hakc_transfer_to_clique(dev->lstats, sizeof(*dev->lstats),
+	// 				      __claque_id_dummy_xmit,
+	// __color_dummy_xmit, false);
+	pr_crit("dummy_xmit: 2-1, dev->lstats: %lx\n", dev->lstats);
+
+	// dev_lstats_add(dev, skb->len);
+
+	struct pcpu_lstats *lstats = this_cpu_ptr(dev->lstats);
+	pr_crit("dummy_xmit: 2-2, lstats: %lx\n", lstats);
+
+	lstats = hakc_transfer_to_clique(lstats, sizeof(*lstats),
+					 __claque_id_dummy_xmit,
+					 __color_dummy_xmit, false);
+
+	pr_crit("dummy_xmit: 3\n");
+
+	u64_stats_update_begin(&lstats->syncp);
+	pr_crit("dummy_xmit: 3-1\n");
+
+	u64_stats_add(&lstats->bytes, skb->len);
+	pr_crit("dummy_xmit: 3-2\n");
+
+	u64_stats_inc(&lstats->packets);
+	pr_crit("dummy_xmit: 3-3\n");
+
+	u64_stats_update_end(&lstats->syncp);
+
+	pr_crit("dummy_xmit: 4\n");
+
+	// skb_tx_timestamp(skb);
+	skb_clone_tx_timestamp(skb);
+
+	pr_crit("dummy_xmit: 4-1, skb->end: %lx\n", skb->end);
+	skb->end = hakc_transfer_to_clique(skb->end, sizeof(unsigned char *),
+					   __claque_id_dummy_xmit,
+					   __color_dummy_xmit, false);
+	skb->head = hakc_transfer_to_clique(skb->head, sizeof(sk_buff_data_t),
+					    __claque_id_dummy_xmit,
+					    __color_dummy_xmit, false);
+
+	pr_crit("dummy_xmit: 4-2, skb->head: %lx, skb->end: %lx\n", skb->head,
+		skb->end);
+
+	// correct
+	struct skb_shared_info *shinfo =
+		(struct skb_shared_info *)(skb->head + skb->end);
+
+	// null pointer dereference
+	// struct skb_shared_info *shinfo = (struct skb_shared_info *)(skb->end);
+
+	pr_crit("dummy_xmit: 4-3, shinfo: %lx\n", shinfo);
+	shinfo = hakc_transfer_to_clique(shinfo, sizeof(*shinfo),
+					 __claque_id_dummy_xmit,
+					 __color_dummy_xmit, false);
+	pr_crit("dummy_xmit: 4-4, shinfo: %lx\n", shinfo);
+
+	__u8 tmp_tx_flags = shinfo->tx_flags;
+	pr_crit("dummy_xmit: 4-5, tmp_tx_flags: %x\n", tmp_tx_flags);
+
+	if (tmp_tx_flags & SKBTX_SW_TSTAMP)
+		skb_tstamp_tx(skb, NULL);
+
+	printk(KERN_CRIT "dummy_xmit: 5\n");
+
+	dev_kfree_skb(skb);
+
+	printk(KERN_CRIT "dummy_xmit: 6\n");
+
+	return NETDEV_TX_OK;
+}
+#else
 static netdev_tx_t dummy_xmit(struct sk_buff *skb, struct net_device *dev)
 {
 	dev_lstats_add(dev, skb->len);
@@ -64,18 +220,34 @@ static netdev_tx_t dummy_xmit(struct sk_buff *skb, struct net_device *dev)
 	dev_kfree_skb(skb);
 	return NETDEV_TX_OK;
 }
+#endif
 
 static int dummy_dev_init(struct net_device *dev)
 {
+	pr_crit("dummy_dev_init: 1\n");
+#if IS_ENABLED(CONFIG_PAC_MTE_COMPART)
+	dev = hakc_transfer_to_clique(dev, sizeof(*dev), __claque_id, __color,
+				      false);
+	dev->lstats = hakc_netdev_alloc_pcpu_stats(struct pcpu_lstats,
+						   __claque_id, __color);
+#else
 	dev->lstats = netdev_alloc_pcpu_stats(struct pcpu_lstats);
+#endif
+
+	pr_crit("dummy_dev_init: 2\n");
 	if (!dev->lstats)
 		return -ENOMEM;
 
+	pr_crit("dummy_dev_init: 3\n");
 	return 0;
 }
 
 static void dummy_dev_uninit(struct net_device *dev)
 {
+#if IS_ENABLED(CONFIG_PAC_MTE_COMPART)
+	dev = hakc_transfer_to_clique(dev, sizeof(*dev), __claque_id, __color,
+				      false);
+#endif
 	free_percpu(dev->lstats);
 }
 
@@ -97,6 +269,7 @@ static const struct net_device_ops dummy_netdev_ops = {
 	.ndo_set_mac_address	= eth_mac_addr,
 	.ndo_get_stats64	= dummy_get_stats64,
 	.ndo_change_carrier	= dummy_change_carrier,
+	.ndo_do_ioctl = dummy_ioctl,
 };
 
 static void dummy_get_drvinfo(struct net_device *dev,
@@ -112,13 +285,22 @@ static const struct ethtool_ops dummy_ethtool_ops = {
 
 static void dummy_setup(struct net_device *dev)
 {
+#if IS_ENABLED(CONFIG_PAC_MTE_COMPART)
+	dev = hakc_transfer_to_clique(dev, sizeof(*dev), __claque_id, __color,
+				      false);
+#endif
+	pr_crit("dummy_setup: 1\n");
 	ether_setup(dev);
 
+	pr_crit("dummy_setup: 2\n");
+
 	/* Initialize the device structure. */
 	dev->netdev_ops = &dummy_netdev_ops;
 	dev->ethtool_ops = &dummy_ethtool_ops;
 	dev->needs_free_netdev = true;
 
+	pr_crit("dummy_setup: 3\n");
+
 	/* Fill in device structure with ethernet-generic values. */
 	dev->flags |= IFF_NOARP;
 	dev->flags &= ~IFF_MULTICAST;
@@ -129,10 +311,26 @@ static void dummy_setup(struct net_device *dev)
 	dev->features	|= NETIF_F_GSO_ENCAP_ALL;
 	dev->hw_features |= dev->features;
 	dev->hw_enc_features |= dev->features;
+
+	pr_crit("dummy_setup: 4\n");
+#if IS_ENABLED(CONFIG_PAC_MTE_COMPART)
+	dev->addr_assign_type = NET_ADDR_RANDOM;
+	// eth_random_addr(dev->dev_addr);
+	dev->dev_addr = hakc_transfer_to_clique(dev->dev_addr, sizeof(dev->dev_addr), __claque_id, __color, false);
+
+	pr_crit("dummy_setup: 5\n");
+	
+	get_random_bytes(dev->dev_addr, ETH_ALEN);
+	dev->dev_addr[0] &= 0xfe; /* clear multicast bit */
+	dev->dev_addr[0] |= 0x02; /* set local assignment bit (IEEE802) */
+#else
 	eth_hw_addr_random(dev);
+#endif
+	pr_crit("dummy_setup: 6\n");
 
 	dev->min_mtu = 0;
 	dev->max_mtu = 0;
+	pr_crit("dummy_setup: 7\n");
 }
 
 static int dummy_validate(struct nlattr *tb[], struct nlattr *data[],
@@ -162,12 +360,23 @@ static int __init dummy_init_one(void)
 	struct net_device *dev_dummy;
 	int err;
 
+	pr_crit("dummy_init_one 1\n");
+
 	dev_dummy = alloc_netdev(0, "dummy%d", NET_NAME_ENUM, dummy_setup);
 	if (!dev_dummy)
 		return -ENOMEM;
+#if IS_ENABLED(CONFIG_PAC_MTE_COMPART)
+	dev_dummy = hakc_transfer_to_clique(dev_dummy, sizeof(*dev_dummy),
+					    __claque_id, __color, false);
+#endif
+	pr_crit("dummy_init_one 2\n");
 
 	dev_dummy->rtnl_link_ops = &dummy_link_ops;
+	pr_crit("dummy_init_one 3\n");
+
 	err = register_netdevice(dev_dummy);
+	pr_crit("dummy_init_one 4\n");
+
 	if (err < 0)
 		goto err;
 	return 0;
@@ -184,17 +393,23 @@ static int __init dummy_init_module(void)
 	down_write(&pernet_ops_rwsem);
 	rtnl_lock();
 	err = __rtnl_link_register(&dummy_link_ops);
+	pr_crit("dummy_init_module 1\n");
+
 	if (err < 0)
 		goto out;
 
 	for (i = 0; i < numdummies && !err; i++) {
+		pr_crit("dummy_init_module 2\n");
 		err = dummy_init_one();
 		cond_resched();
 	}
+
+	pr_crit("dummy_init_module 3\n");
 	if (err < 0)
 		__rtnl_link_unregister(&dummy_link_ops);
 
 out:
+	pr_crit("dummy_init_module 4\n");
 	rtnl_unlock();
 	up_write(&pernet_ops_rwsem);
 
diff --git a/MTE-kernel/net/core/dev.c b/MTE-kernel/net/core/dev.c
index 2015d018c..8b6fd3fd7 100644
--- a/MTE-kernel/net/core/dev.c
+++ b/MTE-kernel/net/core/dev.c
@@ -10014,6 +10014,7 @@ EXPORT_SYMBOL(netif_tx_stop_all_queues);
 
 int register_netdevice(struct net_device *dev)
 {
+	dev = HAKC_GET_SAFE_PTR(dev);
 	int ret;
 	struct net *net = dev_net(dev);
 
diff --git a/MTE-kernel/net/core/skbuff.c b/MTE-kernel/net/core/skbuff.c
index 1301ea694..334dd58b9 100644
--- a/MTE-kernel/net/core/skbuff.c
+++ b/MTE-kernel/net/core/skbuff.c
@@ -698,6 +698,7 @@ EXPORT_SYMBOL(__kfree_skb);
  */
 void kfree_skb(struct sk_buff *skb)
 {
+	skb = HAKC_GET_SAFE_PTR(skb);
 	if (!skb_unref(skb))
 		return;
 
@@ -4761,6 +4762,7 @@ EXPORT_SYMBOL_GPL(__skb_tstamp_tx);
 void skb_tstamp_tx(struct sk_buff *orig_skb,
 		   struct skb_shared_hwtstamps *hwtstamps)
 {
+	orig_skb = HAKC_GET_SAFE_PTR(orig_skb);
 	return __skb_tstamp_tx(orig_skb, hwtstamps, orig_skb->sk,
 			       SCM_TSTAMP_SND);
 }
diff --git a/MTE-kernel/net/core/timestamping.c b/MTE-kernel/net/core/timestamping.c
index 04840697f..e87f21605 100644
--- a/MTE-kernel/net/core/timestamping.c
+++ b/MTE-kernel/net/core/timestamping.c
@@ -21,6 +21,7 @@ static unsigned int classify(const struct sk_buff *skb)
 
 void skb_clone_tx_timestamp(struct sk_buff *skb)
 {
+	skb = HAKC_GET_SAFE_PTR(skb);
 	struct mii_timestamper *mii_ts;
 	struct sk_buff *clone;
 	unsigned int type;
diff --git a/PMC-Pass/src/PMCPass.cpp b/PMC-Pass/src/PMCPass.cpp
index 61c68c7dc..39fc1e059 100644
--- a/PMC-Pass/src/PMCPass.cpp
+++ b/PMC-Pass/src/PMCPass.cpp
@@ -185,27 +185,27 @@ namespace {
      * @brief The set of files to run our analysis on
      */
     const std::set<StringRef> source_files_to_instrument = {
-            "../net/",
-            "../fs/proc/proc_sysctl.c",
-            "../lib/list_debug.c",
-            "../lib/nlattr.c",
-            "../lib/rhashtable.c",
-            "../lib/string.c",
-            "../lib/kobject_uevent.c",
-            "../fs/proc/generic.c",
-            "../kernel/",
-            "../security/commoncap.c",
-            "../drivers/net",
-            "../lib/percpu_counter.c",
-            "../lib/vsprintf.c",
+            "net/",
+            "fs/proc/proc_sysctl.c",
+            "lib/list_debug.c",
+            "lib/nlattr.c",
+            "lib/rhashtable.c",
+            "lib/string.c",
+            "lib/kobject_uevent.c",
+            "fs/proc/generic.c",
+            "kernel/",
+            "security/commoncap.c",
+            "drivers/net",
+            "lib/percpu_counter.c",
+            "lib/vsprintf.c",
     };
 
     /**
      * @brief The set of files to NOT run our analysis on
      */
     const std::set<StringRef> source_files_to_skip = {
-            "../lib/idr.c",
-            "../lib/xarray.c",
+            "lib/idr.c",
+            "lib/xarray.c",
     };
 
     /**
@@ -319,7 +319,7 @@ namespace {
               compartmentalized(isModuleCompartmentalized(Module)),
               moduleModified(false),
               breakOnMissingTransfer(true),
-              debugName("fib6_nh_release"), totalDataChecks(0),
+              debugName("doSomethingDemo"), totalDataChecks(0),
               totalCodeChecks(0), totalTransfers(0) {
 
         bool sourceShouldBeInstrumented = false;
@@ -328,7 +328,12 @@ namespace {
                 std::string::npos &&
                 source_files_to_skip.find(M.getSourceFileName()) ==
                 source_files_to_skip.end()) {
+                if (M.getSourceFileName().find("hakc.c") != std::string::npos || M.getSourceFileName().find("hakc-transfer.c") != std::string::npos) {
+                    errs() << "HAKC source file detected: " << M.getSourceFileName() << ". Skipping XOR instrumentation at API entry points.\n";
+                    break;
+                }
                 sourceShouldBeInstrumented = true;
+                errs() << "Find files to Instrument " << M.getSourceFileName() << "\n";
                 break;
             }
         }
